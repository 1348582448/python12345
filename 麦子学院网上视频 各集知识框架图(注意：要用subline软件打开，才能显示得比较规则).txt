注意：要用subline软件打开，才能显示得比较规则



第六集

让对象具有能动性：

	类的方法的定义：
		与函数定义相似，但必须有参数self。
		其中的参数self在调用方法时由系统自动提供。
		方法定义时必须指明self参数。

	类的方法的调用：
		与普通的函数调用类似
		在类的内部调用：self.<方法名>（参数列表）
		在类的外部调用：<实例名>.<方法名>(参数列表)
		注:以上两种调用方法中，提供的参数列表中都不用包括self

	类内方法相互调用：
		在一个类的内部方法之间是可以相应调用的
		调用方法同上面所述的在类的内部调用方法

	构造方法及其作用：
		构造方法就是前面课程提到和使用的__init__()方法
		构造方法的作用就是在类实例化时初始化实例
		__init__()方法就是类实例化的第二步自动调用的函数 #首先调用new方法
		注意其方法名是固定的，但其参数同普通方法一样，至少应带有self参数
		初始化实例包括：定义和初始化实例属性；或调用类的一些方法
		构造方法可以带有除self外的其它各种参数（关键字参数/默认参数/用元组收集参		数/用字典收集关键字参数等）；
		可以达到在实例化类时，为相应的属性传入指定的值。

	提醒：
		本节课所定义的都是类的实例方法，和实例属性一样，必须进行类实例化之后，才能存在和调用他们。
		这里使用的是python3.x版本，print是一个函数。




第七集
深入类的属性：	
	同名的类属性与实例属性：
		以实例名.属性名引用时，优先引用实例属性        #也暗含用实例名.属性名可以引用类属性，可能是因为类赋值给实例。
		以类名.属性名引用时，只能引用类属性


	属性访问的特殊方法（反射）:
		提供用字符串来操作类的属性/方法的方式
		主要工具函数：
			hasattr(obj_name,'属性名')
			setattr(obj_name,'属性名‘,值')
			getattr（obj_name,'属性名’）

	属性包装
		将方法包装成属性，以隐藏相关实现。
			控制属性的类型或范围
			虚拟属性（由其它属性处理后得来）

		三种属性操作：
			可读：@property
			可写：@<property-name>.setter
			可删：@<property-name>.deleter


	描述符
		将实现特殊协议方法的类作为另一个类的类属性
		用来拦截和控制属性访问并可以重复使用
		协议方法
			__get__()
			__set__()
			__delete__()
		分类
			数据描述符（实现全部协议方法）
			非数据描述符（实现部分协议方法）
			说明：所有类成员函数都是非数据描述符
		同名的实例属性和非数据描述符（以方法为例）访问优先级
		注意：只能在新式类中使用


	__call__()让类的实例如函数一样可调用








第八集
类方法/静态方法
	静态方法
		定义方法：
			@staticmethod装饰
			参数不用self
		访问特性：
			不能引用或访问实例属性
			可以通过类.类变量访问类属性
		调用方法：
			可以用类/类实例属性
		本质：
			在类中的一个普通函数而已
			使面向对象程序中函数归属于类，易于代码管理
		用法：
			与类相关，但不依赖或改变类与实例
			创建不同的实例
			把类相关工具方法放入类中

	类方法：
		定义方法：
			@classmethod
			必须提供参数cls
		访问特性：	
			不能引用或访问实例属性
		调用方法：	
			可以用类/类实例调用
		继承特性：
			继承时，传入的类变量cls是子类，而非父类
		用途：
			与类相关，但不依赖或改变类的实例
			工厂方法，创建类实例，完成有关预处理
			在类内调用静态方法时不用硬编码类名		